<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>太空射击大战</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>

    <canvas id="particle-canvas"></canvas>
    <div class="text-block">
    <p>一个简单的弹幕射击游戏,鼠标控制移动</p>
    <p>使用pygame编写</p>
    </div>
<div class="image-gallery">
    <div class="image-frame">
        <img src="1.png" alt="图1">
    </div>
    <div class="image-frame">
        <img src="2.png" alt="图2">
    </div>
    <div class="image-frame">
        <img src="3.png" alt="图3">
    </div>
</div>
    
    
    

    <script>
        (function() {
            const canvas = document.getElementById('particle-canvas');
            const ctx = canvas.getContext('2d');

            let width, height;
            let dpr = window.devicePixelRatio || 1;

            let particles = [];
            
            // 鼠标交互数据
            let mouseX = -1000, mouseY = -1000;
            let mousePresent = false;

            // ----- 参数配置 (更多粒子，无连线) -----
            const PARTICLE_COUNT = 2000;                    // 大幅增加粒子数量
            const MOUSE_RADIUS = 100;                        // 鼠标影响半径
            const REPEL_FORCE = 0.2;                          // 斥力强度
            const PARTICLE_BASE_OPACITY = 0.85;               // 粒子基础透明度
            const SPEED_FACTOR = 0.6;                          // 速度系数

            // 初始化粒子 (细小均匀)
            function initParticles(w, h) {
                const newParticles = [];
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    newParticles.push({
                        x: Math.random() * w,
                        y: Math.random() * h,
                        vx: (Math.random() - 0.5) * 1.2 * SPEED_FACTOR,
                        vy: (Math.random() - 0.5) * 1.2 * SPEED_FACTOR,
                        radius: 0.5 + Math.random() * 1.3,     // 半径 0.5 ~ 1.8 (细小)
                        alpha: Math.random() * 0.3 + 0.6,      // 个体透明度 0.6~0.9
                    });
                }
                return newParticles;
            }

            // 重置画布 & 粒子
            function resizeCanvas() {
                width = window.innerWidth;
                height = window.innerHeight;

                dpr = window.devicePixelRatio || 1;
                canvas.width = width * dpr;
                canvas.height = height * dpr;
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';

                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.scale(dpr, dpr);

                particles = initParticles(width, height);
            }

            // 全局鼠标监听
            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
                mousePresent = true;
            });

            document.addEventListener('mouseleave', () => {
                mousePresent = false;
            });

            window.addEventListener('blur', () => {
                mousePresent = false;
            });

            // 更新粒子 (无边界环绕)
            function updateParticles() {
                const w = width;
                const h = height;

                // 鼠标斥力
                if (mousePresent && mouseX >= 0 && mouseX <= w && mouseY >= 0 && mouseY <= h) {
                    for (let p of particles) {
                        const dx = p.x - mouseX;
                        const dy = p.y - mouseY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < MOUSE_RADIUS && dist > 0.01) {
                            const force = (1 - dist / MOUSE_RADIUS) * REPEL_FORCE;
                            const angle = Math.atan2(dy, dx);
                            p.vx += Math.cos(angle) * force * 0.5;
                            p.vy += Math.sin(angle) * force * 0.5;

                            const maxSpeed = 2.5;
                            let sp = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                            if (sp > maxSpeed) {
                                p.vx = (p.vx / sp) * maxSpeed;
                                p.vy = (p.vy / sp) * maxSpeed;
                            }
                        }
                    }
                }

                // 位置更新 + 环绕 (无边框)
                for (let p of particles) {
                    p.x += p.vx;
                    p.y += p.vy;

                    // 水平环绕
                    if (p.x < 0) p.x = w;
                    else if (p.x > w) p.x = 0;

                    // 垂直环绕
                    if (p.y < 0) p.y = h;
                    else if (p.y > h) p.y = 0;

                    // 微小阻力
                    p.vx *= 0.998;
                    p.vy *= 0.998;
                }
            }

            // 绘制粒子 (只画粒子，无连线)
            function draw() {
                // 纯黑背景
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, width, height);

                // 绘制所有粒子 (细小光点)
                for (let p of particles) {
                    const opacity = p.alpha * PARTICLE_BASE_OPACITY;
                    ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                    
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fill();

                    // 极小的内部高光 (增加立体感)
                    if (p.radius > 1.0) {
                        ctx.fillStyle = `rgba(255, 255, 255, ${opacity * 0.25})`;
                        ctx.beginPath();
                        ctx.arc(p.x - 0.4, p.y - 0.4, p.radius * 0.3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            // 动画循环
            function animate() {
                updateParticles();
                draw();
                requestAnimationFrame(animate);
            }

            // 启动
            function setup() {
                resizeCanvas();
                animate();

                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        resizeCanvas();
                    }, 100);
                });
            }

            setup();

            // 按钮交互
            const btn = document.getElementById('actionBtn');
            btn.addEventListener('click', () => {
                btn.style.transform = 'scale(0.95)';
                setTimeout(() => {
                    btn.style.transform = 'scale(1)';
                }, 150);
            });

        })();
    </script>
</body>
</html>
